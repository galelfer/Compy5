%{
	#include "hw3_aux.h"
	#include <iostream>
	#include <stdlib.h>

	using namespace std;
	extern int yylex();
	int yyerror(const char * message);

	symbol* symbols = new symbol() ;
    string func_ret_type;
    int loopsCnt = 0;
    string exp_type = "";
    string M1_label="";
    #define YYINITDEPTH 5000

%}


%right ASSIGN
%left OR
%left AND
%left PRERELOP
%nonassoc POSTRELOP
%left PREBINOP
%left POSTBINOP
%right NOT
%left LPAREN RPAREN
%left LBRACE RBRACE
%right IF
%nonassoc ELSE
%nonassoc WHILE
%nonassoc VOID
%nonassoc ID
%nonassoc INT
%nonassoc BYTE
%nonassoc STRING
%nonassoc BOOL
%nonassoc NUM
%nonassoc B
%nonassoc RETURN
%nonassoc CONTINUE
%nonassoc BREAK
%nonassoc TRUE
%nonassoc FALSE
%nonassoc SC
%nonassoc COMMA

%%


Program : INIT Funcs  {symbols->does_main_exist(); CB.printGlobalBuffer() ; CB.printCodeBuffer();}
;

INIT: {symbols->init_global_table(); symbols->init_llvm_stack();}
;

Funcs : FuncDecl Funcs  	{}
      | 			    	{}
;

FuncDecl :  RetType ID LPAREN  Formals RPAREN {symbols->onlyOneMain(yylineno,$2->name); func_ret_type= $1->type; symbols->decl_func($2->name , $4->type , $1->type , $4->name  ,yylineno);} LBRACE Statements RBRACE END_SCOPE  {symbols->finishDeclFunc($1->type);}
;

RetType : Type  		{$$ = new Node($1->name, $1->type , "");}
        | VOID 			{$$ = new Node($1->name, $1->type , "");}
;

Formals : FormalsList    {$$ = new Node($1->name, $1->type , $1->reg);}
        |				 {$$ = new Node("", "" , "");}
;

FormalsList : FormalDecl    			      {if(symbols->get_var($1->name,false) != nullptr) {output::errorDef(yylineno,$1->name); exit(-1);} $$ = new Node($1->name, $1->type , $1->reg);}
            |  FormalDecl COMMA FormalsList   {$$ = new Node($1->name + "," + $3->name, $1->type + "," + $3->type, $1->reg + "," + $3->reg);}
;

FormalDecl : Type ID    		{$$ = new Node($2->name, $1->type , $2->reg);}
;

Statements: Statement 					{$$=$1;}
          | Statements Statement 		{ $$->continuelist=CodeBuffer::merge($2->continuelist,$1->continuelist);
                                          $$->breaklist=CodeBuffer::merge($2->breaklist,$1->breaklist);}
;

Statement : LBRACE NEW_SCOPE Statements RBRACE END_SCOPE {}
	      	|	Type ID SC 							  {symbols->init_var_in_llvmStack($2->name , $1->type , yylineno) ; symbols->add_var($2->name, $1->type, false, yylineno);}
	      	|	Type ID ASSIGN Exp SC 				  {symbols->assign_check_types($1->type, $4->type, yylineno); symbols->add_var($2->name, $1->type, false, yylineno); symbols->boolean_evaluation($4); symbols->assign_value($2->name , $1->type , yylineno , $4->reg); }
	      	|	ID ASSIGN Exp SC 		              {symbols->assign($1->name, $3->type, yylineno); symbols->boolean_evaluation($3); symbols->assign_value($1->name , $3->type , yylineno , $3->reg); }
	      	|	Call SC								  {}
	      	|	RETURN SC							  {symbols->check_types("VOID", func_ret_type , yylineno);}
	      	|	RETURN Exp SC 						  {symbols->check_types($2->type, func_ret_type , yylineno);}
	      	|	IF NEW_SCOPE LPAREN Exp CHECK_TYPE M1 RPAREN Statement END_SCOPE ELSE N NEW_SCOPE M2 Statement END_SCOPE {$$= new Node("" , "BOOL" , ""); symbols->if_else_backpatch($$ , $4 , $8 , $11 , $14 , $13 , M1_label);}
	      	|	IF NEW_SCOPE LPAREN Exp CHECK_TYPE M1 RPAREN Statement  END_SCOPE {$$= new Node("if" , "BOOL" , ""); symbols->if_backpatching($$ , $4 , $8 , M1_label);}
	      	|	WHILE M2 LOOPSCNT NEW_SCOPE LPAREN Exp RPAREN M2 CHECK_TYPE Statement END_SCOPE ELSE N NEW_SCOPE M2 Statement  END_SCOPE {loopsCnt--; $$= new Node("while_else" , "" , ""); symbols->while_else_backpatch($$ , $6 , $10 , $16 , $2 , $8 , $15 , $13);}
	      	|	WHILE M2 LOOPSCNT NEW_SCOPE LPAREN Exp RPAREN M2 CHECK_TYPE Statement END_SCOPE {loopsCnt--; $$= new Node("while" , "" , ""); symbols->while_backpatch($$ , $6 , $10 , $2 , $8);}
	      	|	BREAK SC	 	   {symbols->insideLoop(loopsCnt , "break" , yylineno); symbols->exit_loop($$);}
	      	|	CONTINUE SC	       {symbols->insideLoop(loopsCnt , "continue" , yylineno); symbols->skip_loop($$);}
;

N : {$$=new Node("","","");  int line1=CB.emit("br label @");  $$->nextlist=CodeBuffer::makelist({line1,FIRST});}
;

M2 : {$$=new Node("" , "" , ""); $$->name = CB.genLabel(); }
;

CHECK_TYPE:     {symbols->check_types("BOOL",exp_type, yylineno);}
;

LOOPSCNT :      {loopsCnt++;}
;

NEW_SCOPE :     {symbols->add_scope();}
;

END_SCOPE :      {symbols->remove_scope();}
;

Call : ID LPAREN ExplList RPAREN  {$$=new Node("", symbols->funcType($1->name, $3->type , yylineno), freshVar());}
	 | ID LPAREN RPAREN			 		  	{$$=new Node("", symbols->funcType($1->name, "", yylineno), freshVar());}
;

ExplList : Exp 							{$$ = new Node($1->name, $1->type, $1->reg); symbols->boolean_evaluation($1);}
		 |	Exp COMMA ExplList  		{$$ = new Node($1->name + "," + $3->name, $1->type + "," + $3->type, $1->reg + "," + $3->reg); symbols->boolean_evaluation($1);}
;

Type :  INT   									{$$ = new Node("", "INT", "");}
	 |	BYTE 									{$$ = new Node("", "BYTE", "");}
     |	BOOL								    {$$ = new Node("", "BOOL", "");}
;

Exp : LPAREN Exp RPAREN				{exp_type=$2->type; $$ = new Node($2->name, $2->type, $2->reg);}
	|	Exp PREBINOP Exp			{symbols->check_types($1->type, "INT", yylineno); symbols->check_types($3->type, "INT", yylineno); $$ = new Node("", symbols->larger($1->type, $3->type), freshVar()); exp_type=$$->type; BINOP_proc($$, $1, $2, $3);}
	|	Exp POSTBINOP Exp			{symbols->check_types($1->type, "INT", yylineno); symbols->check_types($3->type, "INT", yylineno); $$ = new Node("", symbols->larger($1->type, $3->type), freshVar());exp_type=$$->type; BINOP_proc($$, $1, $2, $3);}
	|	ID 							{$$ = symbols->makeNodeFromID($1->name,yylineno); exp_type=$$->type;}
	|	Call						{$$ = new Node("", $1->type, $1->reg); exp_type=$$->type; symbols->bool_evaluation_for_call($$); }
	|	NUM 						{$$ = new Node($1->value, "INT", $1->value ,$1->reg); exp_type=$$->type; symbols->forceIntoReg($$);}
	|	NUM B						{symbols->check_valid_b($1->name,yylineno); $$ = new Node($1->value, "BYTE", $1->value ,$1->reg); exp_type=$$->type; symbols->forceIntoReg($$);}
	|	STRING 						{$$ = new Node($1->value, "STRING", $1->value ,$1->reg); exp_type=$$->type; symbols->forceIntoReg($$);}
	|	TRUE						{$$ = $1; exp_type=$$->type; symbols->init_truelist($$);}
	|	FALSE 						{$$ = $1; exp_type=$$->type; symbols->init_falselist($$);}
	|	NOT Exp 					{symbols->check_types($2->type, "BOOL", yylineno); $$ = new Node("", "BOOL", "" , freshVar()); exp_type=$$->type; symbols->swap_truelist_falselist($$,$2);}
	|	Exp AND M1 Exp 				{symbols->check_types($1->type, "BOOL", yylineno); symbols->check_types($4->type, "BOOL", yylineno); $$ = new Node("", "BOOL", "", freshVar()); exp_type=$$->type; symbols->and_backpatch($$,$1,$4,M1_label);}
	|	Exp OR  M1 Exp 				{symbols->check_types($1->type, "BOOL", yylineno); symbols->check_types($4->type, "BOOL", yylineno); $$ = new Node("", "BOOL", "", freshVar()); exp_type=$$->type; symbols->or_backpatch($$,$1,$4,M1_label);}
	|	Exp PRERELOP Exp 		 	{symbols->check_types($1->type, "INT", yylineno); symbols->check_types($3->type, "INT", yylineno); $$ = new Node("", "BOOL", "", freshVar()); exp_type=$$->type; symbols->relop_evaluation($$ , $2->name , $1->reg , $3->reg);}
	|	Exp POSTRELOP Exp 		 	{symbols->check_types($1->type, "INT", yylineno); symbols->check_types($3->type, "INT", yylineno); $$ = new Node("", "BOOL", "", freshVar()); exp_type=$$->type; symbols->relop_evaluation($$ , $2->name , $1->reg , $3->reg);}
;

M1 : { M1_label = CB.genLabel(); }
;

%%

int main()
{
	yyparse();
}

int yyerror(const char * msg)
{
	output::errorSyn(yylineno);
	exit(0);
}
